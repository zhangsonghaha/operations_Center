# 修复文件管理多服务器切换状态同步问题

您遇到的问题是：当快速切换服务器时，前一个服务器的“连接中”状态没有被正确清理或被新请求覆盖，导致状态卡死。这是因为状态管理目前是依赖单实例组件事件触发，而父组件的状态更新逻辑没有处理并发或切换的情况。

## 核心问题分析
1.  **竞态条件**：点击 Server A -> 触发 connecting -> 立即点击 Server B -> Server A 的请求还在进行 -> Server A 请求超时或返回 -> 错误地更新了当前 UI 或状态。
2.  **组件复用问题**：`FileManager` 组件被复用（虽然加了 `key`），但父组件的 `serverStatusMap` 更新逻辑比较简单，没有区分“这是哪个服务器的状态回调”。
3.  **状态隔离不足**：每个服务器的连接状态应该是独立的，不应受当前选中项影响。

## 解决方案
我们将通过以下步骤彻底解决这个问题：

1.  **父组件 (`index.vue`) 增强状态管理**：
    *   修改 `handleConnectionStatus` 方法，使其接收 `serverId` 参数。这样，无论子组件何时回调，父组件都能准确知道是哪个服务器的状态变了，而不是默认更新 `currentServerId`。
    *   确保状态更新是原子且准确的。

2.  **子组件 (`fileManager.vue`) 增强回调**：
    *   在 `emit('connection-status', status)` 时，同时带上 `props.serverId`。
    *   **关键点**：在组件卸载（`onUnmounted`）或 `serverId` 变化时，清理所有的定时器，防止旧的超时逻辑影响新状态。
    *   **请求取消（可选但推荐）**：虽然 JS 不易直接取消 Promise，但我们可以通过标志位 `isCurrentRequest` 来忽略过期的请求回调。

## 执行计划
1.  **修改 `fileManager.vue`**：
    *   增加 `abortController` 或标志位机制，在组件销毁或 ID 变化时忽略旧请求结果。
    *   修改 `emit` 事件，携带 `serverId`。
    *   确保 `setTimeout` 在组件销毁时被清除。

2.  **修改 `views/ops/file/index.vue`**：
    *   更新 `handleConnectionStatus` 方法签名，接收 `(status, serverId)`。
    *   使用传入的 `serverId` 更新 `serverStatusMap`，而不是使用 `currentServerId`。

通过这种方式，即使您快速点击 Server A, B, C，它们各自的请求和超时逻辑都会独立运行，并准确回调给父组件更新对应的红绿灯，互不干扰。
