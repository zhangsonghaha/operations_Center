# 解决快速切换时状态更新滞后问题

您反馈的问题是：在快速切换服务器时，之前的服务器状态（如“连接中”）没有及时更新为“失败”或被清理，导致左侧列表中残留多个“连接中”的状态。这是因为我们虽然在子组件 `FileManager` 中做了定时器清理，但并没有**主动通知父组件**去更新旧服务器的状态。

## 问题根源
当用户从 Server A 切换到 Server B：
1.  Server A 的 `FileManager` 组件被销毁（`onUnmounted`）。
2.  我们在 `onUnmounted` 中清理了 Server A 的超时定时器。
3.  **关键缺失**：父组件 `index.vue` 中的 `serverStatusMap[ServerA]` 仍然停留在最后一次收到的状态（通常是“connecting”），因为 `onUnmounted` 时没有发送“连接中断”或“取消”的状态更新给父组件。

## 解决方案
我们需要在组件销毁时，如果状态仍为“连接中”，主动通知父组件将其重置或标记为特定状态（如“未连接”或“取消”）。

### 1. 修改 `FileManager.vue`
*   在 `onUnmounted` 生命周期钩子中：
    *   检查当前 `loading` 状态。
    *   如果仍在 `loading`（说明请求未完成就被切走了），不仅要清除定时器，还要 `emit` 一个状态更新（例如 `status: 'idle'` 或保持原状但允许父组件处理）。
    *   更合理的做法是：切换走了就不应该显示“连接中”了，应该重置为初始状态（idle/未连接）或者保留上一次的有效状态。鉴于用户意图是“我不看它了”，将其重置为“未连接”或“空闲”是比较合理的，避免列表里全是“连接中”。

### 2. 修改 `views/ops/file/index.vue`
*   无需大改，只要子组件在销毁时发出了正确的状态更新，父组件现有的 `handleConnectionStatus` 逻辑就能正确更新 UI。
*   另外，为了防止请求回调在组件销毁后依然触发（虽然我们清了定时器，但 Promise 的 `.then` 还是可能会执行），我们需要一个标志位 `isUnmounted` 来阻断销毁后的回调。

## 执行计划
1.  **修改 `FileManager.vue`**：
    *   增加 `isUnmounted` 标志位。
    *   在 `onUnmounted` 中：
        *   设置 `isUnmounted = true`。
        *   清除定时器。
        *   如果 `loading` 为 true，emit `{ status: 'idle', serverId }`，让父组件把状态改回灰色（未连接/空闲），表示连接尝试已中断。
    *   在 `listFiles` 的 `.then` 和 `.catch` 中，首先检查 `isUnmounted`，如果是 true 则直接 return，不执行任何 emit 操作。

这样，一旦您切换走，旧服务器的状态会立即变回“未连接”（灰色），只有当前选中的服务器会显示“连接中”或最终结果。
